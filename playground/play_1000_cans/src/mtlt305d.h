/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.1.2 Mon Aug 22 10:27:11 2022.
 */

#ifndef MTLT305D_H
#define MTLT305D_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define MTLT305D_REQUEST_PGN_FRAME_ID (0x18eaff00u)
#define MTLT305D_ACEINNA_ADDRESS_CLAIMING_FRAME_ID (0x18eeff80u)
#define MTLT305D_SET_CONFIGURATION_SAVE_FRAME_ID (0x18ff5100u)
#define MTLT305D_FEEDBACK_SOFTWARE_BIT_FRAME_ID (0x18ff5380u)
#define MTLT305D_FEEDBACK_HARDWARE_BIT_FRAME_ID (0x18ff5280u)
#define MTLT305D_FEEDBACK_ECU_ID_FRAME_ID (0x18fdc580u)
#define MTLT305D_FEEDBACK_FIRMWARE_VERSION_FRAME_ID (0x18feda80u)
#define MTLT305D_SET_BANK1_PS_NUM_FRAME_ID (0x18fff100u)
#define MTLT305D_SET_BANK0_PS_NUM_FRAME_ID (0x18fff000u)
#define MTLT305D_SET_ORIENTATION_FRAME_ID (0x18ff5800u)
#define MTLT305D_SET_DIGITAL_FILTER_FRAME_ID (0x18ff5700u)
#define MTLT305D_SET_DATA_PCKET_TYPE_FRAME_ID (0x18ff5600u)
#define MTLT305D_SET_PACKET_RATE_DIVIDER_FRAME_ID (0x18ff5500u)
#define MTLT305D_SET_ALGORITHM_RESET_FRAME_ID (0x18ff5000u)
#define MTLT305D_FEEDBACK_CONFIGURATION_SAVE_FRAME_ID (0x18ff5180u)
#define MTLT305D_FEEDBACK_SENSOR_STATUS_FRAME_ID (0x18ff5480u)
#define MTLT305D_ACEINNA_ANGLE_RATE_FRAME_ID (0xcf02a80u)
#define MTLT305D_ACEINNA_ACCEL_FRAME_ID (0x8f02d80u)
#define MTLT305D_ACEINNA_ANGLES_FRAME_ID (0xcf02980u)

/* Frame lengths in bytes. */
#define MTLT305D_REQUEST_PGN_LENGTH (3u)
#define MTLT305D_ACEINNA_ADDRESS_CLAIMING_LENGTH (8u)
#define MTLT305D_SET_CONFIGURATION_SAVE_LENGTH (3u)
#define MTLT305D_FEEDBACK_SOFTWARE_BIT_LENGTH (2u)
#define MTLT305D_FEEDBACK_HARDWARE_BIT_LENGTH (2u)
#define MTLT305D_FEEDBACK_ECU_ID_LENGTH (8u)
#define MTLT305D_FEEDBACK_FIRMWARE_VERSION_LENGTH (5u)
#define MTLT305D_SET_BANK1_PS_NUM_LENGTH (8u)
#define MTLT305D_SET_BANK0_PS_NUM_LENGTH (8u)
#define MTLT305D_SET_ORIENTATION_LENGTH (3u)
#define MTLT305D_SET_DIGITAL_FILTER_LENGTH (3u)
#define MTLT305D_SET_DATA_PCKET_TYPE_LENGTH (2u)
#define MTLT305D_SET_PACKET_RATE_DIVIDER_LENGTH (2u)
#define MTLT305D_SET_ALGORITHM_RESET_LENGTH (3u)
#define MTLT305D_FEEDBACK_CONFIGURATION_SAVE_LENGTH (3u)
#define MTLT305D_FEEDBACK_SENSOR_STATUS_LENGTH (8u)
#define MTLT305D_ACEINNA_ANGLE_RATE_LENGTH (8u)
#define MTLT305D_ACEINNA_ACCEL_LENGTH (8u)
#define MTLT305D_ACEINNA_ANGLES_LENGTH (8u)

/* Extended or standard frame types. */
#define MTLT305D_REQUEST_PGN_IS_EXTENDED (1)
#define MTLT305D_ACEINNA_ADDRESS_CLAIMING_IS_EXTENDED (1)
#define MTLT305D_SET_CONFIGURATION_SAVE_IS_EXTENDED (1)
#define MTLT305D_FEEDBACK_SOFTWARE_BIT_IS_EXTENDED (1)
#define MTLT305D_FEEDBACK_HARDWARE_BIT_IS_EXTENDED (1)
#define MTLT305D_FEEDBACK_ECU_ID_IS_EXTENDED (1)
#define MTLT305D_FEEDBACK_FIRMWARE_VERSION_IS_EXTENDED (1)
#define MTLT305D_SET_BANK1_PS_NUM_IS_EXTENDED (1)
#define MTLT305D_SET_BANK0_PS_NUM_IS_EXTENDED (1)
#define MTLT305D_SET_ORIENTATION_IS_EXTENDED (1)
#define MTLT305D_SET_DIGITAL_FILTER_IS_EXTENDED (1)
#define MTLT305D_SET_DATA_PCKET_TYPE_IS_EXTENDED (1)
#define MTLT305D_SET_PACKET_RATE_DIVIDER_IS_EXTENDED (1)
#define MTLT305D_SET_ALGORITHM_RESET_IS_EXTENDED (1)
#define MTLT305D_FEEDBACK_CONFIGURATION_SAVE_IS_EXTENDED (1)
#define MTLT305D_FEEDBACK_SENSOR_STATUS_IS_EXTENDED (1)
#define MTLT305D_ACEINNA_ANGLE_RATE_IS_EXTENDED (1)
#define MTLT305D_ACEINNA_ACCEL_IS_EXTENDED (1)
#define MTLT305D_ACEINNA_ANGLES_IS_EXTENDED (1)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/**
 * Signals in message Request_PGN.
 *
 * Send data for different messages:
00 FE DA	Firmware Version
00 FD C5	Give ECU the sensor ID
00 FF 52 	Hardware Bit
00 FF 53 	Software Bit
00 FF 54 	Sensor Status

 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_request_pgn_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message Aceinna_Address_Claiming.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_aceinna_address_claiming_t {
    /**
     * Arbitrary Address Capable
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_arbitrary_address;

    /**
     * Industry Group
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_industry_group;

    /**
     * Vehicle System Instance
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_vehicle_example;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_vehicle_system;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_reserved0;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_function;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_function_example;

    /**
     * Range: -4..3 (-4..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_ecu_example;

    /**
     * Most significant 8 bits of Manufacturer Code
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t j1939_name_manufacture_code;

    /**
     * Least significant 3 bits of Manufacturer Code
     *
     * Range: -16..15 (-16..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t j1939_name_id_code;
};

/**
 * Signals in message Set_Configuration_Save.
 *
 * data: 00 80
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_configuration_save_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_request_or_response;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_saved_address;

    /**
     * Byte Description Value
     * 0 Request or Response 0 =Request, 1=Response
     * 1 Address of Unit
     * being saved
     * Address of destination
     * 2 Success or failure 0=failure, 1=success
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_failure_or_success;
};

/**
 * Signals in message Feedback_Software_Bit.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_feedback_software_bit_t {
    /**
     * 0=normal, 1=internal software error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sw_software_error;

    /**
     * 0=normal, 1=error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sw_algorithm_error;

    /**
     * 0=normal, 1=error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sw_data_error;

    /**
     * 0=normal, 1=internal software error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sw_initialization_error;

    /**
     * 0=normal, 1=Algorithm need to be reset
     * do to sensor over range
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sw_over_range;

    /**
     * 0=normal, 1=incorrect CRC
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sw_calibration_crc_error;

    /**
     * 0=normal, 1=incorrect CRC
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t aceinna_sw_reserved0;
};

/**
 * Signals in message Feedback_Hardware_BIT.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_feedback_hardware_bit_t {
    /**
     * 0=normal, 1=fatal error has occurred
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_hw_master_fai;

    /**
     * 0=normal, 1=internal hardware error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_hw_sensor_error;

    /**
     * 0=normal, 1=internal gyro error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_hw_rate_error;

    /**
     * 0=normal, 1=internal accelerometer
     * error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_hw_accell_error;

    /**
     * 0=normal, 1=internal accelerometer
     * error
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t aceinna_hw_reserved0;
};

/**
 * Signals in message Feedback_ECU_ID.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_feedback_ecu_id_t {
    /**
     * Arbitrary Address Capable
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_arbitrary_address;

    /**
     * Industry Group
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_industry_group;

    /**
     * Vehicle System Instance
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_vehicle_example;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_vehicle_system;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_reserved0;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_function;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_function_example;

    /**
     * Range: -4..3 (-4..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t j1939_name_ecu_example;

    /**
     * Most significant 8 bits of Manufacturer Code
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t j1939_name_manufacture_code;

    /**
     * Least significant 3 bits of Manufacturer Code
     *
     * Range: -16..15 (-16..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t j1939_name_id_code;
};

/**
 * Signals in message Feedback_Firmware_Version.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_feedback_firmware_version_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_firm_version_major;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_firm_version_minor;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_firm_version_patch;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_firm_version_stage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_firm_version_build;
};

/**
 * Signals in message Set_Bank1_PS_Num.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_bank1_ps_num_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_packet_rate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_type;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_digital_filter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_orientation;
};

/**
 * Signals in message Set_Bank0_PS_Num.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_bank0_ps_num_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_algo_rest;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_hw_bit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_sw_bit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_ps_num_status;
};

/**
 * Signals in message Set_Orientation.
 *
 * data: 80 00 00 (+Ux, +Uy, +Uz example��
other selections pls refer to user manual
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_orientation_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_destination_address;

    /**
     * Pls check with 4.1.5.6 in below link:
     * https://www.aceinna.com/userfiles/files/User-Manuals/7430-3305-02_User_Manual_MTLT305D.pdf
     * 
     * 
     * 
     * 
     * 
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t aceinna_new_orientation_type;
};

/**
 * Signals in message Set_Digital_Filter.
 *
 * data: 80 17 05 (rate and accel are 25hz)
other selections pls refer user manual
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_digital_filter_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_destination_address;

    /**
     *  Cutoff Frequency choices are 0, 2, 5, 10, 20, 25, 40 and
     * 50Hz, for low pass filter
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_new_gyro_low_pass;

    /**
     * Cutoff Frequency choices are 0, 2, 5, 10, 20, 25, 40
     * and 50Hz, for acceleration low pass filter
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_new_acc_low_pass;
};

/**
 * Signals in message Set_Data_Pcket_Type.
 *
 * data: 80 07 (SSI2, Angular Rate and Acceleration---default)
other type pls refer to user manual
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_data_pcket_type_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_destination_address;

    /**
     * Byte Value Data Packet Type
     * 1 SSI2
     * 2 Angular Rate
     * 3 SSI2 and Angular Rate
     * 4 Acceleration
     * 5 SSI2 and Acceleration
     * 6 Angular Rate and Acceleration
     * 7 SSI2, Angular Rate and Acceleration
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_new_packet_type;
};

/**
 * Signals in message Set_Packet_Rate_Divider.
 *
 * data: 80 01 (100hz---default)
other frequency pls refer to user manual
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_packet_rate_divider_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_destination_address;

    /**
     * Byte Value Packet broadcasting rate
     * 0 Quiet mode
     * 1 100Hz (default)
     * 2 50Hz
     * 4 25Hz
     * 5 20Hz
     * 10 10Hz
     * 20 5Hz
     * 25 4Hz
     * 50 2Hz
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_new_pocket_rate;
};

/**
 * Signals in message Set_Algorithm_Reset.
 *
 * 00 80 
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_set_algorithm_reset_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_request_or_response;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_saved_address;

    /**
     * Byte Description Value
     * 0 Request or Response 0 =Request, 1=Response
     * 1 Address of Unit
     * being saved
     * Address of destination
     * 2 Success or failure 0=failure, 1=success
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t aceinna_failure_or_success;
};

/**
 * Signals in message Feedback_Configuration_Save.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_feedback_configuration_save_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_request_or_response;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_saved_address;

    /**
     * Byte Description Value
     * 0 Request or Response 0 =Request, 1=Response
     * 1 Address of Unit
     * being saved
     * Address of destination
     * 2 Success or failure 0=failure, 1=success
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_failure_or_success;
};

/**
 * Signals in message Feedback_Sensor_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_feedback_sensor_status_t {
    /**
     * Range: 0..1 (0..1 N/A)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_master_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_hardware_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_software_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sensor_status;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_reserved0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_unlocked_eeprom;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_algo_init;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_reserved1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_attitude_only_algo;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_turn_switch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_sensor_over_range;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_reserved3;
};

/**
 * Signals in message Aceinna_AngleRate.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_aceinna_angle_rate_t {
    /**
     * Gyro_X
     *
     * Range: 0..65535 (-250..261.9921875 deg/s)
     * Scale: 0.0078125
     * Offset: -250
     */
    uint16_t aceinna_gyro_x;

    /**
     * Gyro_Y
     *
     * Range: 0..65535 (-250..261.9921875 deg/s)
     * Scale: 0.0078125
     * Offset: -250
     */
    uint16_t aceinna_gyro_y;

    /**
     * Gyro_Z
     *
     * Range: 0..65535 (-250..261.9921875 deg/s)
     * Scale: 0.0078125
     * Offset: -250
     */
    uint16_t aceinna_gyro_z;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_pitch_rate_figure_of_merit;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_roll_rate_figure_of_merit;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_yaw_rate_figure_of_merit;

    /**
     * Time between start of sensor processing and CAN transmission
     *
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t aceinna_angle_rate_latency;
};

/**
 * Signals in message Aceinna_Accel.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_aceinna_accel_t {
    /**
     * ACC_X
     *
     * Range: 0..65535 (-320..335.35 m/s2)
     * Scale: 0.01
     * Offset: -320
     */
    uint16_t aceinna_acc_x;

    /**
     * ACC_Y
     *
     * Range: 0..65535 (-320..335.35 m/s2)
     * Scale: 0.01
     * Offset: -320
     */
    uint16_t aceinna_acc_y;

    /**
     * Acc_Z
     *
     * Range: 0..65535 (-320..335.35 m/s2)
     * Scale: 0.01
     * Offset: -320
     */
    uint16_t aceinna_acc_z;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_lateral_acc_figure_of_merit;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_longi_acc_figure_of_merit;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_vertic_acc_figure_of_merit;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_support_rate_acc;
};

/**
 * Signals in message Aceinna_Angles.
 *
 * All signal values are as on the CAN bus.
 */
struct mtlt305d_aceinna_angles_t {
    /**
     * Pitch
     *
     * Range: 0..16449536 (-250..252 deg)
     * Scale: 3.0517578125e-05
     * Offset: -250
     */
    uint32_t aceinna_pitch;

    /**
     * Roll
     *
     * Range: 0..16449536 (-250..252 deg)
     * Scale: 3.0517578125e-05
     * Offset: -250
     */
    uint32_t aceinna_roll;

    /**
     * Compensated mode for the pitch measurement.  Compensation is the use of multiple sensors together to enhance the output of the pitch measurement.
     * 
     * 00 = On
     * 01 = Off
     * 10 = Error
     * 11 = Not Available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_pitch_compensation;

    /**
     * Figure of merit for pitch angle measurement.
     * 
     * 00 = Pitch angle fully functional. Data is within sensor specification.
     * 01 = Pitch angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_pitch_figure_of_merit;

    /**
     * Compensated mode for the roll angle measurement.  Compensation is the use of multiple sensors together to enhance the output of the roll angle measurement.
     * 
     * 00 = On
     * 01 = Off
     * 10 = Error
     * 11 = Not Available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_roll_compensation;

    /**
     * Figure of merit for roll angle measurement.
     * 
     * 00 = Roll angle fully functional. Data is within sensor specification.
     * 01 = Roll angle degraded. Data is suspect due to environmental conditions.
     * 10 = Error
     * 11 = Not available
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t aceinna_roll_figure_of_merit;

    /**
     * Time between start of sensor processing and CAN transmission
     *
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t aceinna_pitch_roll_latency;
};

/**
 * Pack message Request_PGN.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_request_pgn_pack(
    uint8_t *dst_p,
    const struct mtlt305d_request_pgn_t *src_p,
    size_t size);

/**
 * Unpack message Request_PGN.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_request_pgn_unpack(
    struct mtlt305d_request_pgn_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message Aceinna_Address_Claiming.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_aceinna_address_claiming_pack(
    uint8_t *dst_p,
    const struct mtlt305d_aceinna_address_claiming_t *src_p,
    size_t size);

/**
 * Unpack message Aceinna_Address_Claiming.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_aceinna_address_claiming_unpack(
    struct mtlt305d_aceinna_address_claiming_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_arbitrary_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_arbitrary_address_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_arbitrary_address_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_industry_group_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_industry_group_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_industry_group_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_vehicle_example_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_vehicle_example_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_vehicle_example_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_vehicle_system_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_vehicle_system_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_vehicle_system_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_reserved0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_reserved0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_reserved0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_function_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_function_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_function_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_function_example_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_function_example_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_function_example_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_address_claiming_j1939_name_ecu_example_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_ecu_example_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_ecu_example_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_address_claiming_j1939_name_manufacture_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_manufacture_code_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_manufacture_code_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t mtlt305d_aceinna_address_claiming_j1939_name_id_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_address_claiming_j1939_name_id_code_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_address_claiming_j1939_name_id_code_is_in_range(uint32_t value);

/**
 * Pack message Set_Configuration_Save.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_configuration_save_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_configuration_save_t *src_p,
    size_t size);

/**
 * Unpack message Set_Configuration_Save.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_configuration_save_unpack(
    struct mtlt305d_set_configuration_save_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_configuration_save_aceinna_request_or_response_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_configuration_save_aceinna_request_or_response_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_configuration_save_aceinna_request_or_response_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_configuration_save_aceinna_saved_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_configuration_save_aceinna_saved_address_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_configuration_save_aceinna_saved_address_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_configuration_save_aceinna_failure_or_success_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_configuration_save_aceinna_failure_or_success_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_configuration_save_aceinna_failure_or_success_is_in_range(int8_t value);

/**
 * Pack message Feedback_Software_Bit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_feedback_software_bit_pack(
    uint8_t *dst_p,
    const struct mtlt305d_feedback_software_bit_t *src_p,
    size_t size);

/**
 * Unpack message Feedback_Software_Bit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_feedback_software_bit_unpack(
    struct mtlt305d_feedback_software_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_software_bit_aceinna_sw_software_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_software_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_software_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_software_bit_aceinna_sw_algorithm_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_algorithm_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_algorithm_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_software_bit_aceinna_sw_data_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_data_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_data_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_software_bit_aceinna_sw_initialization_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_initialization_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_initialization_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_software_bit_aceinna_sw_over_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_over_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_over_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_software_bit_aceinna_sw_calibration_crc_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_calibration_crc_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_calibration_crc_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_feedback_software_bit_aceinna_sw_reserved0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_software_bit_aceinna_sw_reserved0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_software_bit_aceinna_sw_reserved0_is_in_range(uint16_t value);

/**
 * Pack message Feedback_Hardware_BIT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_feedback_hardware_bit_pack(
    uint8_t *dst_p,
    const struct mtlt305d_feedback_hardware_bit_t *src_p,
    size_t size);

/**
 * Unpack message Feedback_Hardware_BIT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_feedback_hardware_bit_unpack(
    struct mtlt305d_feedback_hardware_bit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_hardware_bit_aceinna_hw_master_fai_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_hardware_bit_aceinna_hw_master_fai_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_hardware_bit_aceinna_hw_master_fai_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_hardware_bit_aceinna_hw_sensor_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_hardware_bit_aceinna_hw_sensor_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_hardware_bit_aceinna_hw_sensor_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_hardware_bit_aceinna_hw_rate_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_hardware_bit_aceinna_hw_rate_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_hardware_bit_aceinna_hw_rate_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_hardware_bit_aceinna_hw_accell_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_hardware_bit_aceinna_hw_accell_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_hardware_bit_aceinna_hw_accell_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_feedback_hardware_bit_aceinna_hw_reserved0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_hardware_bit_aceinna_hw_reserved0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_hardware_bit_aceinna_hw_reserved0_is_in_range(uint16_t value);

/**
 * Pack message Feedback_ECU_ID.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_feedback_ecu_id_pack(
    uint8_t *dst_p,
    const struct mtlt305d_feedback_ecu_id_t *src_p,
    size_t size);

/**
 * Unpack message Feedback_ECU_ID.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_feedback_ecu_id_unpack(
    struct mtlt305d_feedback_ecu_id_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_arbitrary_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_arbitrary_address_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_arbitrary_address_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_industry_group_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_industry_group_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_industry_group_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_vehicle_example_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_vehicle_example_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_vehicle_example_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_vehicle_system_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_vehicle_system_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_vehicle_system_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_reserved0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_reserved0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_reserved0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_function_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_function_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_function_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_function_example_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_function_example_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_function_example_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_ecu_id_j1939_name_ecu_example_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_ecu_example_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_ecu_example_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_feedback_ecu_id_j1939_name_manufacture_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_manufacture_code_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_manufacture_code_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t mtlt305d_feedback_ecu_id_j1939_name_id_code_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_ecu_id_j1939_name_id_code_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_ecu_id_j1939_name_id_code_is_in_range(uint32_t value);

/**
 * Pack message Feedback_Firmware_Version.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_feedback_firmware_version_pack(
    uint8_t *dst_p,
    const struct mtlt305d_feedback_firmware_version_t *src_p,
    size_t size);

/**
 * Unpack message Feedback_Firmware_Version.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_feedback_firmware_version_unpack(
    struct mtlt305d_feedback_firmware_version_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_firmware_version_aceinna_firm_version_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_firmware_version_aceinna_firm_version_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_firmware_version_aceinna_firm_version_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_firmware_version_aceinna_firm_version_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_firmware_version_aceinna_firm_version_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_firmware_version_aceinna_firm_version_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_firmware_version_aceinna_firm_version_patch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_firmware_version_aceinna_firm_version_patch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_firmware_version_aceinna_firm_version_patch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_firmware_version_aceinna_firm_version_stage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_firmware_version_aceinna_firm_version_stage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_firmware_version_aceinna_firm_version_stage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_firmware_version_aceinna_firm_version_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_firmware_version_aceinna_firm_version_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_firmware_version_aceinna_firm_version_build_is_in_range(uint8_t value);

/**
 * Pack message Set_Bank1_PS_Num.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_bank1_ps_num_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_bank1_ps_num_t *src_p,
    size_t size);

/**
 * Unpack message Set_Bank1_PS_Num.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_bank1_ps_num_unpack(
    struct mtlt305d_set_bank1_ps_num_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank1_ps_num_aceinna_ps_num_packet_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank1_ps_num_aceinna_ps_num_packet_rate_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank1_ps_num_aceinna_ps_num_packet_rate_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank1_ps_num_aceinna_ps_num_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank1_ps_num_aceinna_ps_num_type_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank1_ps_num_aceinna_ps_num_type_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank1_ps_num_aceinna_ps_num_digital_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank1_ps_num_aceinna_ps_num_digital_filter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank1_ps_num_aceinna_ps_num_digital_filter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank1_ps_num_aceinna_ps_num_orientation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank1_ps_num_aceinna_ps_num_orientation_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank1_ps_num_aceinna_ps_num_orientation_is_in_range(int8_t value);

/**
 * Pack message Set_Bank0_PS_Num.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_bank0_ps_num_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_bank0_ps_num_t *src_p,
    size_t size);

/**
 * Unpack message Set_Bank0_PS_Num.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_bank0_ps_num_unpack(
    struct mtlt305d_set_bank0_ps_num_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank0_ps_num_aceinna_ps_num_algo_rest_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank0_ps_num_aceinna_ps_num_algo_rest_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank0_ps_num_aceinna_ps_num_algo_rest_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank0_ps_num_aceinna_ps_num_hw_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank0_ps_num_aceinna_ps_num_hw_bit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank0_ps_num_aceinna_ps_num_hw_bit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank0_ps_num_aceinna_ps_num_sw_bit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank0_ps_num_aceinna_ps_num_sw_bit_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank0_ps_num_aceinna_ps_num_sw_bit_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_bank0_ps_num_aceinna_ps_num_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_bank0_ps_num_aceinna_ps_num_status_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_bank0_ps_num_aceinna_ps_num_status_is_in_range(int8_t value);

/**
 * Pack message Set_Orientation.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_orientation_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_orientation_t *src_p,
    size_t size);

/**
 * Unpack message Set_Orientation.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_orientation_unpack(
    struct mtlt305d_set_orientation_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_orientation_aceinna_destination_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_orientation_aceinna_destination_address_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_orientation_aceinna_destination_address_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mtlt305d_set_orientation_aceinna_new_orientation_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_orientation_aceinna_new_orientation_type_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_orientation_aceinna_new_orientation_type_is_in_range(int16_t value);

/**
 * Pack message Set_Digital_Filter.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_digital_filter_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_digital_filter_t *src_p,
    size_t size);

/**
 * Unpack message Set_Digital_Filter.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_digital_filter_unpack(
    struct mtlt305d_set_digital_filter_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_digital_filter_aceinna_destination_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_digital_filter_aceinna_destination_address_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_digital_filter_aceinna_destination_address_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_digital_filter_aceinna_new_gyro_low_pass_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_digital_filter_aceinna_new_gyro_low_pass_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_digital_filter_aceinna_new_gyro_low_pass_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_digital_filter_aceinna_new_acc_low_pass_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_digital_filter_aceinna_new_acc_low_pass_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_digital_filter_aceinna_new_acc_low_pass_is_in_range(int8_t value);

/**
 * Pack message Set_Data_Pcket_Type.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_data_pcket_type_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_data_pcket_type_t *src_p,
    size_t size);

/**
 * Unpack message Set_Data_Pcket_Type.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_data_pcket_type_unpack(
    struct mtlt305d_set_data_pcket_type_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_data_pcket_type_aceinna_destination_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_data_pcket_type_aceinna_destination_address_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_data_pcket_type_aceinna_destination_address_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_data_pcket_type_aceinna_new_packet_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_data_pcket_type_aceinna_new_packet_type_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_data_pcket_type_aceinna_new_packet_type_is_in_range(int8_t value);

/**
 * Pack message Set_Packet_Rate_Divider.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_packet_rate_divider_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_packet_rate_divider_t *src_p,
    size_t size);

/**
 * Unpack message Set_Packet_Rate_Divider.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_packet_rate_divider_unpack(
    struct mtlt305d_set_packet_rate_divider_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_packet_rate_divider_aceinna_destination_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_packet_rate_divider_aceinna_destination_address_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_packet_rate_divider_aceinna_destination_address_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_packet_rate_divider_aceinna_new_pocket_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_packet_rate_divider_aceinna_new_pocket_rate_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_packet_rate_divider_aceinna_new_pocket_rate_is_in_range(int8_t value);

/**
 * Pack message Set_Algorithm_Reset.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_set_algorithm_reset_pack(
    uint8_t *dst_p,
    const struct mtlt305d_set_algorithm_reset_t *src_p,
    size_t size);

/**
 * Unpack message Set_Algorithm_Reset.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_set_algorithm_reset_unpack(
    struct mtlt305d_set_algorithm_reset_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_algorithm_reset_aceinna_request_or_response_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_algorithm_reset_aceinna_request_or_response_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_algorithm_reset_aceinna_request_or_response_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_algorithm_reset_aceinna_saved_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_algorithm_reset_aceinna_saved_address_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_algorithm_reset_aceinna_saved_address_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t mtlt305d_set_algorithm_reset_aceinna_failure_or_success_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_set_algorithm_reset_aceinna_failure_or_success_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_set_algorithm_reset_aceinna_failure_or_success_is_in_range(int8_t value);

/**
 * Pack message Feedback_Configuration_Save.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_feedback_configuration_save_pack(
    uint8_t *dst_p,
    const struct mtlt305d_feedback_configuration_save_t *src_p,
    size_t size);

/**
 * Unpack message Feedback_Configuration_Save.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_feedback_configuration_save_unpack(
    struct mtlt305d_feedback_configuration_save_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_configuration_save_aceinna_request_or_response_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_configuration_save_aceinna_request_or_response_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_configuration_save_aceinna_request_or_response_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_configuration_save_aceinna_saved_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_configuration_save_aceinna_saved_address_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_configuration_save_aceinna_saved_address_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_configuration_save_aceinna_failure_or_success_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_configuration_save_aceinna_failure_or_success_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_configuration_save_aceinna_failure_or_success_is_in_range(uint8_t value);

/**
 * Pack message Feedback_Sensor_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_feedback_sensor_status_pack(
    uint8_t *dst_p,
    const struct mtlt305d_feedback_sensor_status_t *src_p,
    size_t size);

/**
 * Unpack message Feedback_Sensor_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_feedback_sensor_status_unpack(
    struct mtlt305d_feedback_sensor_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_master_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_master_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_master_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_hardware_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_hardware_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_hardware_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_software_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_software_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_software_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_sensor_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_sensor_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_sensor_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_reserved0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_reserved0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_reserved0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_unlocked_eeprom_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_unlocked_eeprom_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_unlocked_eeprom_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_algo_init_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_algo_init_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_algo_init_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_reserved1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_reserved1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_reserved1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_attitude_only_algo_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_attitude_only_algo_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_attitude_only_algo_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_turn_switch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_turn_switch_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_turn_switch_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_sensor_over_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_sensor_over_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_sensor_over_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_feedback_sensor_status_aceinna_reserved3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_feedback_sensor_status_aceinna_reserved3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_feedback_sensor_status_aceinna_reserved3_is_in_range(uint8_t value);

/**
 * Pack message Aceinna_AngleRate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_aceinna_angle_rate_pack(
    uint8_t *dst_p,
    const struct mtlt305d_aceinna_angle_rate_t *src_p,
    size_t size);

/**
 * Unpack message Aceinna_AngleRate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_aceinna_angle_rate_unpack(
    struct mtlt305d_aceinna_angle_rate_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_angle_rate_aceinna_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_gyro_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_gyro_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_angle_rate_aceinna_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_gyro_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_gyro_y_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_angle_rate_aceinna_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_gyro_z_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_gyro_z_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angle_rate_aceinna_pitch_rate_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_pitch_rate_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_pitch_rate_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angle_rate_aceinna_roll_rate_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_roll_rate_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_roll_rate_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angle_rate_aceinna_yaw_rate_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_yaw_rate_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_yaw_rate_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angle_rate_aceinna_angle_rate_latency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angle_rate_aceinna_angle_rate_latency_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angle_rate_aceinna_angle_rate_latency_is_in_range(uint8_t value);

/**
 * Pack message Aceinna_Accel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_aceinna_accel_pack(
    uint8_t *dst_p,
    const struct mtlt305d_aceinna_accel_t *src_p,
    size_t size);

/**
 * Unpack message Aceinna_Accel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_aceinna_accel_unpack(
    struct mtlt305d_aceinna_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_accel_aceinna_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_acc_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_acc_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_accel_aceinna_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_acc_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_acc_y_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mtlt305d_aceinna_accel_aceinna_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_acc_z_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_acc_z_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_accel_aceinna_lateral_acc_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_lateral_acc_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_lateral_acc_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_accel_aceinna_longi_acc_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_longi_acc_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_longi_acc_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_accel_aceinna_vertic_acc_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_vertic_acc_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_vertic_acc_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_accel_aceinna_support_rate_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_accel_aceinna_support_rate_acc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_accel_aceinna_support_rate_acc_is_in_range(uint8_t value);

/**
 * Pack message Aceinna_Angles.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mtlt305d_aceinna_angles_pack(
    uint8_t *dst_p,
    const struct mtlt305d_aceinna_angles_t *src_p,
    size_t size);

/**
 * Unpack message Aceinna_Angles.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mtlt305d_aceinna_angles_unpack(
    struct mtlt305d_aceinna_angles_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t mtlt305d_aceinna_angles_aceinna_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_pitch_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_pitch_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t mtlt305d_aceinna_angles_aceinna_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_roll_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_roll_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angles_aceinna_pitch_compensation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_pitch_compensation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_pitch_compensation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angles_aceinna_pitch_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_pitch_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_pitch_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angles_aceinna_roll_compensation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_roll_compensation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_roll_compensation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angles_aceinna_roll_figure_of_merit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_roll_figure_of_merit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_roll_figure_of_merit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mtlt305d_aceinna_angles_aceinna_pitch_roll_latency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mtlt305d_aceinna_angles_aceinna_pitch_roll_latency_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mtlt305d_aceinna_angles_aceinna_pitch_roll_latency_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
